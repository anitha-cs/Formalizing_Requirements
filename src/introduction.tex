\section{Introduction}
\label{sec:intro}

Complex cyber-physical systems are often developed hierarchically through decomposition of a ``top level'' system into layers of smaller and more manageable components.  Decomposition is performed to accommodate reuse, integration with existing or commercially developed components, and distributed development, as well as to factor the complexity of development~\cite{Hammond01:WiW}, and the process of decomposition typically involves identifying  components and their interconnections as well as allocating requirements to each of them. One of the challenging tasks in this process is determining \emph{``if the composition of component behaviours satisfy the overall system requirements?''}. In safety critical systems, formal methods (mathematical techniques) can be used to rigorously ensure the correctness of systems. However, adopting formal techniques alone does not guarantee the correctness of the system.

The challenge in successfully using formal methods lies in precisely stating ``what" needs to be verified and thoroughly understanding ``how" it is verified, rather than the action of verification itself. Nowadays, sophisticated techniques and tools can help automatically verify the correctness of models with respect to some properties of interest.  But these tools rely on the skill level of the engineers to \emph{formalize} the requirements and understand the details of the tools used. For example, using formal tools one could successfully prove a set of logically inconsistent or vacuous requirements and be happy about the successful but meaningless verification. While, there are numerous success stories that illustrate the benefits of using formal methods~\cite{Miller03:shalls,Whalen07:FMICS} as well as discussion about the limitations of formal methods~\cite{Limits of Formal Methods,Ralf Kneuper and myths about FM}, there are not adequate discussions about the practical challenges encountered and techniques adopted to mitigate them while using formal methods in real applications. We believe that, sharing such experiences will allow the wider dissemination of formal methods in industrial use.

In previous work~\cite{hilt2013, req2code} we proposed scalable and efficient model based approaches to verify the formalized requirements of complex control systems, given its architecture (hierarchical decomposition into components) and the formalized requirements. The approach involves hierarchically modeling, formalizing and verifying requirements of system and its components using multiple tools (Simulink, Simulink Design Verifier~\cite{SimulinkDesignVerifier} and AADL/AGREE~\cite{NFM2012:CoGaMiWhLaLu}), each with slightly different formal representations and usage. While this approach was undoubtedly useful to verify large complex systems effectively, when we used it to verify a industry sized infusion pump system, a medical device, we faced a number of practical challenges that had the potential to undermine the value of not just our approach but formal requirements analysis in general. To the best of our knowledge these challenges, that lie in the intersection of the requirements engineering and formal verification domains, have not been discussed in depth and addressed in any existing literature.

In this paper we describe those practical challenges we faced in the process of constructing models and formalizing requirements at multiple levels of hierarchy when applying tools ``at scale'' involving several developers over an extended period of time.  We focus on four challenges:
\begin{description}
    \item[Requirements Formalization:] Systematically identifying the contextual information while formalizing the requirements from traditionally documented natural language requirements is a time consuming task. In our earlier efforts to formalize the requirements of control systems, although they were documented using standard patterns~\cite{mavin2009easy} and templates, we spent a number of hours to precisely formalize it, i.e to identify the precise antecedent/ precondition. To overcome this challenge, we propose a hierarchical structuring scheme to document requirements, that we believe, not only clarifies the context for each requirement while formalizing them but also naturally reflects how requirements are conceived by the stakeholders in the critical system domain. %While, the proposed structuring scheme is most relevant to control systems, we believe it can be tailored to suit other domains as well. \anitha{...SHOULD I SAY THIS LAST LINE? May be we should say we are talking about control systems only}
    %Formalizing requirements for verification not only involves translating the natural language statements into a mathematical notations but the need to systematically identify the contextual information of the requirements that, unfortunately, is not easily inferable from the traditional ways of documenting natural language requirements. In our effort to formalize the requirements of the infusion pump, although it was documented using a standard pattern based approach~\cite{EARS} and templates, we spent a number of hours to identify the context for each requirement while formalizing it -- in formal terms identifying the precise antecedent or precondition. We found that the primary reason for this difficulty is the way the requirements statements were structured. To overcome this challenge, we propose a hierarchical structuring scheme to document requirements. While our structuring scheme is most relevant to control systems, we believe it can be tailored to suit other domains as well.
    \item[Requirements Refinement:]  We initially mapped system requirements to software requirements as is advocated in~\cite{Miller01:dasc} (and used in other papers such as~\cite{Jeffords:2010:MCV:1938390.1938407,Kauppinen07:re}), but found that applying this approach led to incorrect compositions when we tried to prove system requirements.
    \item[Tool Fallibilities:] In an architectural proof approach, all proofs are predicated on ``leaf-level'' components meeting their specification.  If these leaf-level specifications are incorrect (for example, it is not possible to construct an implementation meeting the specification or it is inconsistent after a certain number of time steps of execution), then the proof is not well-founded.  This has forced us to develop tools towards checking {\em realizability} and strengthen the existing {\em consistency checking} of requirements.
    \item[Matching Tool Boundaries] For scalability concerns, we had to move verification results from one tool to another. However, the mere action of transcription of requirements between different notations of the tools (even through the tools shared the ``same" semantics) induced several errors that lead to misplaced confidence in results. This motivated us to implement tools and rigours practices to systematically check the translation.
\end{description}

The contribution of the paper is reporting the challenges and pitfalls that engineers typically encounter while formally reasoning about complex control system requirements, especially in the safety critical system domain. We also describe the solutions that we adopted to overcome those challenges. While we illustrate these lessons learnt using the infusion pump as a case example, we believe many engineers working on similar applications will face similar challenges, so we hope that sharing our experiences prove instructive. %The intent of this paper is to serve as as lessons learnt and best practices for practitioners and researchers involved in similar efforts.

The paper is organized as follows. In Section \ref{sec:gpca-overview} we provide a brief overview of our previous effort that serves as a context for the issues described later. In Section \ref{sec:challenge} we explain the specific challenges and pitfalls we encountered while verifying the infusion pump system. In Section \ref{sec:related}, we elaborate our approachs and recommendations to address the challenges. Finally, we conclude the paper in Section \ref{sec:conc}.
\iffalse

%
%applying hierarchical reasoning amongst a team of developers over time on a complex system architecture.
%
%constructing models, determining requirements for different levels within the hierarchical description (e.g., describing top-level software vs. system requirements), and correctly formalising English-language requirements.  It extends the work in~\cite{hilt2013}, as we have scaled up this description to a much more substantial model.
%
%The approach was based on the presumption that the we correctly formalized the requirements of both system and components and understood how the tools worked; unfortunately that was not an easy task.
%
%be formalized using a variant of temporal logic, that was unfortunately a challenging task. Further, .
%%required us to we faced a number of challenges in the process of precisely formalizing and verifying the requirements, the
%% and deriving component requirements from the natural language system requirements as well as ensuring if they are accurately verified.


\anitha{I would like to explain the 4 challenges in the introduction. But it has become 4 long paragraphs.}
%
In particular, we focus on four challenges that we believe have not been discussed in depth in existing literature. First of all, systematically identifying dependencies between requirements while formalizing them from a traditionally structured requirements document is challenging. Typically, system requirements are captured using natural language and organized as per one of existing requirements document templates~\cite{IEEE formats}. However, we found that this traditional structuring of the requirements makes the task of formalizing requirements arduous and error prone. \mike{What does this mean?  Dependencies in what sense?  I don't understand this paragraph}


%, and our approach to address them Hence, we restructured the infusion pump requirements in an unique way that made it conceptually easy to understand and formalize.

Secondly, we found that understanding the mathematical differences between formalized system and component requirements is crucial, since it may otherwise lead to inaccurate analysis of the system. While decomposing the system and allocating requirements to components, especially the software of the system, it has been a practice~\cite{extending4variabe} to replicate the system requirements into software requirements by just changing the scope. However, while formalizing the requirements for the infusion pump software, we found that most system's requirements were typically expressed to account for tolerances, whereas the corresponding software requirements did not need such allowances. In mathematical terms, the former was relational whereas the latter was functional. We realized that failing to recognize such mathematical differences between the requirements may result in incorrect assurance of the system. %To identify such errors, we used a richer traceability document for the infusion pump.

\anitha{Should i mention which tool we use here?}
Thirdly, we posit that cursory knowledge about how the formal tools perform  verification can lead to highly believable but erroneous results. While verifying the requirements of the infusion pump, we found that the tool successfully verified requirements that were inconsistently formalized. While the tool was sophisticated enough to detect such issues, it could do so only if certain options were explicitly set in the tool's configuration; that, unfortunately, was not obvious. Although the root cause of the `cursory knowledge' was due to the limited information provided by the tool about such options along with the verification results, this ultimately resulted in successful proofs of inconsistent requirements.

Finally, we also found that when recapturing verification results from one tool to another, even if their notations have the ``same" semantics, the mere transcription of requirements from one notation to the other may lead to elusive errors. To verify the infusion pump system we used two tools in a successive fashion such that the verification results from one tool will be used by the other. Although the notation used in both the tools to formalise requirements were semantically same, the mere action of recapturing the requirements between the tools resulted in transcription errors that were difficult to detect.

By ``cursory knowledge'', we mean the engineer's knowledge about all the default or normal configuration of the verification tool, that are often hidden. does not make it explicit, it may be unreasonable to expect the engineers to have in-depth tool knowledge,   %Such options are usually intensionally disabled by default to improve the tools performance. Hence, it relies on the expertise and knowledge of the engineer to recognize the need for such options. When we found such issues with the help our tool expert, we requested the tool developers to make such configuration information obvious to users.

Given the architectural model of the system and formalized requirements (both system and the components), we used tool called AGREE (Assume Guarantee Reasoning Environment) to automatically verify if the decomposed component requirements are sufficient to guarantee the system level requirements. Subsequently, we also verified if the component requirements are indeed satisfiable by each of their respective implementations (modeled using Simulink/Stateflow tool), using MathWorks Simulink Design verifier (SDV) tool. This tool chain allowed us to rigorously verify the decomposition of the infusion pump requirements in a scalable and efficient manner. However, the process of precisely formalizing requirements and deriving component requirements from the natural language system requirements was a non-trivial activity. In the following sections, we elaborate on the challenges  and our approaches we address them.
The intent of this paper is to serve as a report of practical challenges and lessons learnt while using formal methods to engineer requirements of safety critical systems from a practitioner's perspective.

Infusion pumps have been involved in many incidents, posing hazards to patients, due to their malfunction. To contribute to The US Food and Drug Administration's (FDA)~\cite{fda2010whitepaper} initiative to improve the safe development of these devices, we demonstrated an end-to-end model based approach to develop high assurance infusion pumps using a generic infusion pump system.

The overall system requirements especially for complex control systems such as GPCA are typically captured to accommodate certain degree of inaccuracies and imperfections in the environment, that interacts with the system, and the physical components, that would be used to construct the system. But, when the GPCA was decomposed and requirements were allocated to components the degree of inaccuracies and imperfections in component requirements changes (typically reduces). However, it has been a common perception that most system requirements can trace almost entirely to requirements on one component and hence such system requirements can be recaptured into identical component requirements~\cite{Miller01:dasc}. Unfortunately, in our experience, we found that although some component requirements might seem to be similar to their corresponding system level requirement, a simple recapture of the requirements might be risky. For instance, while GPCA system requirements included tolerances, the GPCA's software did not require such tolerances in their requirements, due to its deterministic behavior. In mathematical terms, while the system requirements were expressed as relations, the software requirements were expressed as functions. Failing to recognize such differences in mathematical notations while formalizing requirements lead to misunderstanding about the decomposition.

Even after precisely capturing the requirements formalizing them for verification from its natural language source was another challenge. We found that operational requirements, that describe the functions performed by a system under normal operating conditions, typically captured using natural language can be easily understood and interpreted. However, when formalizing them for verification it is often the case that it insufficient to just recapture what has been specified in natural language. It is necessary to identify and preclude the exceptional conditions/scenarios that prevent the normal functions from occurring. In the GPCA, to verify if the system infuses drug into patients at a specified rate for a specified amount of time, we had to formalize the requirement in such a way that all the exceptional conditions that will not allow the infusion to occur is excluded. These conditions are usually specified in another requirements but it was a laborious trial and error task to identify them and formalize them appropriately. While one could argue that this is due to imprecisely specified natural language requirements, in practice, these concerns prop up only during formal verification. Although there are numerous case studies that describe success stories of using formal methods to verify requirements, unfortunately none of them elaborate on their approaches and challenges involved in formalizing such requirements.

Further, the results from formal tools could be misleading if one lacks in-depth understanding of how the tools perform verification. One well known problem with formal tools is verifying requirements \emph{vacuously} - in other words successfully verifying a requirement in an unintended (say trivial) manner. Similarly, in our experience we found that it is easy to unknowingly formalize and successfully verify internally inconsistent requirements, if we do not have an indepth understanding of how the specific tool verifies such requirements. While the tools that we used to verify GPCA had the capability to identify such issues, they had to be explicitly enabled in the tool's configuration. Since, such options were intensionally disabled by default to improve the tools performance, it relies on the expertise and knowledge of the engineer to recognize the need for such options. Failing to understand these tool configurations may cause believable but misleading verification results.

While it is well known that there is no "one size fits all" tool/notation to verify requirements especially large and complex ones, bridging the boundaries between different tools to perform system verification is often very problematic. When we use multiple tools and notations to capture and verify requirements, one well known challenge is rigorously bridging the syntactic and semantic differences between them. However we found that, even if they share the "same" semantics, the translation and verification of requirements between tools leads to errors that were difficult to detect.

In practice, the act of formalizing the requirements in a way that is verifiable and decomposing them into component requirements from its natural language source is not an easy task.

\fi
