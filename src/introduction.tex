
\section{Introduction}
\label{sec:intro}
\vspace{-0.1in}
%Complex cyber-physical systems are often developed hierarchically through decomposition of a ``top level'' system into layers of smaller and more manageable components.  Decomposition is performed to accommodate reuse, integration with existing or commercially developed components, and distributed development, as well as to factor the complexity of development~\cite{Hammond01:WiW}, and the process of decomposition typically involves identifying  components and their interconnections as well as allocating requirements to each of them. One of the challenging tasks in this process is determining \emph{``if the composition of component behaviors satisfy the overall system requirements?''}.

In safety critical systems, formal methods (mathematical techniques) are often used to rigorously assure the correctness of systems. %However, the challenge in successfully using formal methods lies in precisely stating ``what" needs to be verified and thoroughly understanding ``how" it is verified, rather than the action of verification itself.
While advances in technology has improved the verification capability and efficiency of formal tools such as model checkers, they still rely on the skill level of the engineers to correctly formalize requirements
and understand the technicalities of the tools. For instance, one could use a set of inconsistently (or incorrectly restrictive) formalized premises to prove requirements using formal tools and gain misplaced confidence about the successful but meaningless verification. While there are numerous success stories that illustrate the benefits of using formal methods~\cite{Miller03:shalls,Whalen07:FMICS} as well as discussions about the limitations of formal methods~\cite{kneuper1997limits,hall1990seven}, we believe that % there are aspects of application of formal methods that remain necessary to discuss.
there are not adequate discussions about the practical challenges encountered and techniques adopted to mitigate them in real applications.
In our opinion, codifying the pitfalls will allow wider and better dissemination of formal methods in industrial use.

In previous work~\cite{hilt2013, req2code, ICCPS2014}, we proposed scalable and efficient model based approaches to verify the formalized requirements of complex control systems, given their architecture (hierarchical decomposition into components) and formalized requirements. The approach involved hierarchically modeling, formalizing and verifying the requirements of the system and its components using multiple tools% (Simulink, Simulink Design Verifier~\cite{SimulinkDesignVerifier} and AADL/AGREE~\cite{NFM2012:CoGaMiWhLaLu})
, each with slightly different formal representations and usage. While this approach was useful to verify hierarchically decomposed systems, when we used it to verify an substantially complex medical infusion pump system, we faced a number of practical challenges and pitfalls that had the potential to undermine the value of not just our approach but formal requirements analysis in general. To the best of our knowledge these challenges, that lie in the intersection of the requirements engineering and formal verification domains, have not been discussed in depth and addressed in any existing literature.

In this paper we discuss the challenges we faced while formally verifying requirements at multiple levels of hierarchy, applying tools and techniques ``at scale'' involving several developers over an extended period of time.  We focus on four challenges:
\vspace{-0.15in}
\paragraph{\textbf{Requirements Formalization:}} Identifying the contextual information when formalizing requirements from a traditionally structured requirements document is a challenging task. In our effort to formalize the requirements of an infusion pump, we spent an enormous amount of time to identify the context for each requirement, even though the requirements were organized as per standard templates~\cite{IEEESRS}. This is mainly because the way of the requirement statements are linearly organized within the document did not help precisely identify its context. To overcome this challenge, we hierarchically organized the requirements within the document that not only clarified the context for each requirement while formalizing them but also improved the clarity of the document.
\vspace{-0.15in}
\paragraph{\textbf{Requirements Refinement:}} When systems are decomposed and requirements are allocated to its components, establishing the fidelity between the system and its component requirements is a challenge, especially when system requirements are informally expressed and component requirements are formally specified. While decomposing the infusion pump system, we derived formal software requirements from the natural language system requirements using an approach proposed by Miller et.al~\cite{Miller01:dasc} (also used in other papers such as~\cite{jeffords2010model,kauppinen2007re, lempia2009requirements}), but found that it led to incorrect compositions when we tried to establish system requirements. %The approach does not consider the inherent relational aspect of system requirements and the functional aspect of  requirements of components like software, that lead to incorrect requirements allocation.
To address this concern, we propose documenting a \emph{satisfaction argument}, originally described by Jackson~\cite{jackson1995world}, that captures the relationship between the system and component requirements as well the assumptions that are necessary to establish that relationship. Explicitly documenting this argument for every requirement allowed us to validate both the requirements allocated to the components and the related assumptions.
\vspace{-0.15in}
\paragraph{\textbf{Cursory Knowledge of Tools:}} In an hierarchical architectural proof approach, all proofs are predicated on ``leaf level'' components meeting their requirements. If these leaf-level requirements are incorrect (infeasible or inconsistent), then the proof is not well-founded. While formalizing the leaf level component requirements for the infusion pump, we unknowingly formalized some computations used within requirements in a inconsistent and unrealizable way, that was not detected by the tools and lead to misplaced confidence about the system. This prompted us to request for changes and enhancements to the tool in checking the {\em realizability}~\cite{gacek2015towards} and {\em consistency} of requirements.
\vspace{-0.15in}
\paragraph{\textbf{Matching Tool Boundaries:}} In order to be able to reason at scale about complex systems, we found it necessary to use multiple reasoning tools at different levels of abstraction within the software architecture. This use necessitated translation of properties between multiple tools. However, the mere action of transcription of requirements between different notations of the tools (even through the tools shared the ``same" semantics) induced several errors that lead to misplaced confidence in results. To have adequate confidence in the composition of the results, tools to translate between formalisms were required.

The contribution of the paper is reporting the challenges and non-obvious nuances in using formal methods to verify requirements of complex systems that, we believe, engineers will likely encounter. To some extent, although these limitations seem obvious once stated, in our experience, these issues are not fully realized and mitigated by some parts of the formal requirements analysis community. While we illustrate our lessons learned using the infusion pump we believe many engineers working on similar applications, especially in the safety critical system domain, will face similar challenges and hence we hope that sharing our experience proves instructive.

%is two-fold: first, we report on the successful application of formal methods on a large and complex software architecture (the completion of the work in~\cite{hilt2013}). Second, we
%reporting the challenges in using formal methods to verify requirements of complex systems, that engineers will likely encounter especially in the safety-critical domain, and how we addressed these challenges. %In sum, we assert that the benefits of formal methods in verifying requirements can be misleading, unless there is a change in both requirements engineering activities to support formal methods as well as in formal techniques to recognize requirement engineering concerns. In this paper, we report on the challenges and non-obvious nuances in using formal methods to verify an infusion pump's requirements. We also describe our approach to overcome those challenges from both requirements engineering and formal methods perspective.
%While we illustrate these lessons learned using the infusion pump we believe many engineers working on similar applications, especially in the safety critical system domain, will face similar challenges and hence we hope that sharing our experience proves instructive. %The intent of this paper is to serve as lessons learnt and best practices for practitioners and researchers involved in similar efforts.

%The paper is organized as follows. In Section \ref{sec:gpca-overview} we provide a brief overview of our previous effort that serves as a context for the rest of the paper. In Section \ref{sec:challenge}, we explain the challenges we encountered along with our approaches and recommendations to address them. Finally, we conclude the paper in Section \ref{sec:conclusion}.

\iffalse

%
%applying hierarchical reasoning amongst a team of developers over time on a complex system architecture.
%
%constructing models, determining requirements for different levels within the hierarchical description (e.g., describing top-level software vs. system requirements), and correctly formalising English-language requirements.  It extends the work in~\cite{hilt2013}, as we have scaled up this description to a much more substantial model.
%
%The approach was based on the presumption that the we correctly formalized the requirements of both system and components and understood how the tools worked; unfortunately that was not an easy task.
%
%be formalized using a variant of temporal logic, that was unfortunately a challenging task. Further, .
%%required us to we faced a number of challenges in the process of precisely formalizing and verifying the requirements, the
%% and deriving component requirements from the natural language system requirements as well as ensuring if they are accurately verified.


\anitha{I would like to explain the 4 challenges in the introduction. But it has become 4 long paragraphs.}
%
In particular, we focus on four challenges that we believe have not been discussed in depth in existing literature. First of all, systematically identifying dependencies between requirements while formalizing them from a traditionally structured requirements document is challenging. Typically, system requirements are captured using natural language and organized as per one of existing requirements document templates~\cite{IEEE formats}. However, we found that this traditional structuring of the requirements makes the task of formalizing requirements arduous and error prone. \mike{What does this mean?  Dependencies in what sense?  I don't understand this paragraph}


%, and our approach to address them Hence, we restructured the infusion pump requirements in an unique way that made it conceptually easy to understand and formalize.

Secondly, we found that understanding the mathematical differences between formalized system and component requirements is crucial, since it may otherwise lead to inaccurate analysis of the system. While decomposing the system and allocating requirements to components, especially the software of the system, it has been a practice~\cite{extending4variabe} to replicate the system requirements into software requirements by just changing the scope. However, while formalizing the requirements for the infusion pump software, we found that most system's requirements were typically expressed to account for tolerances, whereas the corresponding software requirements did not need such allowances. In mathematical terms, the former was relational whereas the latter was functional. We realized that failing to recognize such mathematical differences between the requirements may result in incorrect assurance of the system. %To identify such errors, we used a richer traceability document for the infusion pump.

\anitha{Should i mention which tool we use here?}
Thirdly, we posit that cursory knowledge about how the formal tools perform  verification can lead to highly believable but erroneous results. While verifying the requirements of the infusion pump, we found that the tool successfully verified requirements that were inconsistently formalized. While the tool was sophisticated enough to detect such issues, it could do so only if certain options were explicitly set in the tool's configuration; that, unfortunately, was not obvious. Although the root cause of the `cursory knowledge' was due to the limited information provided by the tool about such options along with the verification results, this ultimately resulted in successful proofs of inconsistent requirements.

Finally, we also found that when recapturing verification results from one tool to another, even if their notations have the ``same" semantics, the mere transcription of requirements from one notation to the other may lead to elusive errors. To verify the infusion pump system we used two tools in a successive fashion such that the verification results from one tool will be used by the other. Although the notation used in both the tools to formalise requirements were semantically same, the mere action of recapturing the requirements between the tools resulted in transcription errors that were difficult to detect.

By ``cursory knowledge'', we mean the engineer's knowledge about all the default or normal configuration of the verification tool, that are often hidden. does not make it explicit, it may be unreasonable to expect the engineers to have in-depth tool knowledge,   %Such options are usually intensionally disabled by default to improve the tools performance. Hence, it relies on the expertise and knowledge of the engineer to recognize the need for such options. When we found such issues with the help our tool expert, we requested the tool developers to make such configuration information obvious to users.

Given the architectural model of the system and formalized requirements (both system and the components), we used tool called AGREE (Assume Guarantee Reasoning Environment) to automatically verify if the decomposed component requirements are sufficient to guarantee the system level requirements. Subsequently, we also verified if the component requirements are indeed satisfiable by each of their respective implementations (modeled using Simulink/Stateflow tool), using MathWorks Simulink Design verifier (SDV) tool. This tool chain allowed us to rigorously verify the decomposition of the infusion pump requirements in a scalable and efficient manner. However, the process of precisely formalizing requirements and deriving component requirements from the natural language system requirements was a non-trivial activity. In the following sections, we elaborate on the challenges  and our approaches we address them.
The intent of this paper is to serve as a report of practical challenges and lessons learnt while using formal methods to engineer requirements of safety critical systems from a practitioner's perspective.

Infusion pumps have been involved in many incidents, posing hazards to patients, due to their malfunction. To contribute to The US Food and Drug Administration's (FDA)~\cite{fda2010whitepaper} initiative to improve the safe development of these devices, we demonstrated an end-to-end model based approach to develop high assurance infusion pumps using a generic infusion pump system.

The overall system requirements especially for complex control systems such as GPCA are typically captured to accommodate certain degree of inaccuracies and imperfections in the environment, that interacts with the system, and the physical components, that would be used to construct the system. But, when the GPCA was decomposed and requirements were allocated to components the degree of inaccuracies and imperfections in component requirements changes (typically reduces). However, it has been a common perception that most system requirements can trace almost entirely to requirements on one component and hence such system requirements can be recaptured into identical component requirements~\cite{Miller01:dasc}. Unfortunately, in our experience, we found that although some component requirements might seem to be similar to their corresponding system level requirement, a simple recapture of the requirements might be risky. For instance, while GPCA system requirements included tolerances, the GPCA's software did not require such tolerances in their requirements, due to its deterministic behavior. In mathematical terms, while the system requirements were expressed as relations, the software requirements were expressed as functions. Failing to recognize such differences in mathematical notations while formalizing requirements lead to misunderstanding about the decomposition.

Even after precisely capturing the requirements formalizing them for verification from its natural language source was another challenge. We found that operational requirements, that describe the functions performed by a system under normal operating conditions, typically captured using natural language can be easily understood and interpreted. However, when formalizing them for verification it is often the case that it insufficient to just recapture what has been specified in natural language. It is necessary to identify and preclude the exceptional conditions/scenarios that prevent the normal functions from occurring. In the GPCA, to verify if the system infuses drug into patients at a specified rate for a specified amount of time, we had to formalize the requirement in such a way that all the exceptional conditions that will not allow the infusion to occur is excluded. These conditions are usually specified in another requirements but it was a laborious trial and error task to identify them and formalize them appropriately. While one could argue that this is due to imprecisely specified natural language requirements, in practice, these concerns prop up only during formal verification. Although there are numerous case studies that describe success stories of using formal methods to verify requirements, unfortunately none of them elaborate on their approaches and challenges involved in formalizing such requirements.

Further, the results from formal tools could be misleading if one lacks in-depth understanding of how the tools perform verification. One well known problem with formal tools is verifying requirements \emph{vacuously} - in other words successfully verifying a requirement in an unintended (say trivial) manner. Similarly, in our experience we found that it is easy to unknowingly formalize and successfully verify internally inconsistent requirements, if we do not have an in-depth understanding of how the specific tool verifies such requirements. While the tools that we used to verify GPCA had the capability to identify such issues, they had to be explicitly enabled in the tool's configuration. Since, such options were intensionally disabled by default to improve the tools performance, it relies on the expertise and knowledge of the engineer to recognize the need for such options. Failing to understand these tool configurations may cause believable but misleading verification results.

While it is well known that there is no "one size fits all" tool/notation to verify requirements especially large and complex ones, bridging the boundaries between different tools to perform system verification is often very problematic. When we use multiple tools and notations to capture and verify requirements, one well known challenge is rigorously bridging the syntactic and semantic differences between them. However we found that, even if they share the "same" semantics, the translation and verification of requirements between tools leads to errors that were difficult to detect.

In practice, the act of formalizing the requirements in a way that is verifiable and decomposing them into component requirements from its natural language source is not an easy task.

(that is also used in other papers such as~\cite{jeffords2010model,kauppinen2007re, lempia2009requirements}),

\fi
