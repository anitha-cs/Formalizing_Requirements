\subsection{Tool Fallibilities}

Although we used sophisticated tools with advanced capabilities such as consistency checks, cursory knowledge about how the tools perform such checks lead us to successfully verify inconsistent requirements. The tool we used, AGREE, had capabilities such as consistency check in addition to verification of requirements. The consistency check features detects logical contradictions among requirements. The intent of performing such checks is to identify if the verification was trivially successful due to presence of such inconsistent requirements. While all the GPCA software requirements were successful, our tool expert, during the manually inspection phase, found that there were several self-inconsistent requirements. Surprising those inconsistencies were not identified by the tool. This was primarily because we did not have full knowledge of the tools setting that associated with that check.

Lets us illustrate the problem with an concrete example. To formalize certain requirements for GPCA we had to specify counters that could keep track of duration of internal conditions or occurrence of certain actions. For example, consider a requirement to notify the clinician when the patient requests more than a certain number of boluses. To formalize this requirement we had to count the number of requests received \texttt{(PatientRequest)} by the system. Hence, we declared an integer variable \texttt{(boluscnt)}, whose initial value was 0 and then gets incremented whenever a \texttt{PatientRequest} is received by the system, as shown below. In AGREE, "->" is used to capture the initial and subsequent value computations for a variable.

$$ \texttt{boluscnt:int = 0 -> boluscnt + PatientRequest} $$

While the tool successfully verified the requirement involving the \texttt{boluscnt} variable, during manual inspection our tool expert pointed out this statement was internally inconsistent. The inconsistency was due to the usage of \texttt{boluscnt} in both the right and left side of the equation. According to the tool, the value for \texttt{boluscnt} always refers to its value in the current time step, whereas we actually intended to refer to the value in the previous time step in the right side of the expression. The incorrect formulation had caused a circular dependency in assigning values for \texttt{boluscnt} variable, that made this expression and the requirement involving this variable inconsistent and trivially satisfied. In the GPCA, we identified 10 such inconsistent formalizations. To address this issue, we used AGREE's operator \emph{``pre"}, that refers to the value of a variable in the previous step as shown below.

$$ \texttt{boluscnt:int = 0 -> pre(boluscnt) + PatientRequest} $$

While adding \emph{``pre"} fixed this particular requirement's inconsistency, our concern was that the tool's consistency checker did not identify this problem. After discussing with the tool developers, we found that the tool was set up by default to check for consistency only in the initial time step (first step of execution). This was not a bug in the tool, rather an intensional default setting to optimize the performance of the tool. According to the tool developers, most inconsistencies can be found in the first step and this was an exceptional condition. Since the \texttt{boluscnt} equation was inconsistent only after the initial step, the consistency checker did not report the problem.


%Hence, when the tool developers
%
%Although the tool was sophisticated enough to allow this default setting to be changed, the real problem was our cursory knowledge about the tool and the fact that it was not obvious from the tool results. While we fixed this issue by both changing the formalization as well as enhancing the tool to display the number of time steps for consistency check, the risk of specifying such inconsistent requirements could only be avoided if we had through understanding of the tool.
%
%In our opinion, this situation is not limited to this specific example or tool but generalizable for all model checking tools and techniques. Our advice to mitigate this problem, in addition to validating the formalization with domain and tool experts, is to get an indepth understanding of the tool settings that performs such checks and validations, rather than blindly trusting the results from the tool.

